#include "AIMManager.h"

const char kThreadName[] = "IMKit: AIM Protocol";

void PrintHex(unsigned char* buf, size_t size) {
	int i = 0;
	int j = 0;
	int breakpoint = 0;

	for(;i < size; i++) {
		fprintf(stdout, "%02x ", (unsigned char)buf[i]);
		breakpoint++;	

		if(!((i + 1)%16) && i) {
			fprintf(stdout, "\t\t");
			for(j = ((i+1) - 16); j < ((i+1)/16) * 16; j++)	{
				if(buf[j] < 30) {
					fprintf(stdout, ".");
				} else {
					fprintf(stdout, "%c", (unsigned char)buf[j]);
				};
			}
			fprintf(stdout, "\n");
			breakpoint = 0;
		}
	}
	
	if(breakpoint == 16) {
		fprintf(stdout, "\n");
		return;
	}

	for(; breakpoint < 16; breakpoint++) {
		fprintf(stdout, "   ");
	}
	
	fprintf(stdout, "\t\t");

	for(j = size - (size%16); j < size; j++) {
		if(buf[j] < 30) {
			fprintf(stdout, ".");
		} else {
			fprintf(stdout, "%c", (unsigned char)buf[j]);
		};
	}
	
	fprintf(stdout, "\n");
}


AIMManager::AIMManager(void) {	
	fSock = -1;
	fOutgoingSeqNum = 10;
	fIncomingSeqNum = 0;
	
};

AIMManager::~AIMManager(void) {
	delete fRunner;
};

void AIMManager::Start(void) {
	fSockThread = spawn_thread(MonitorSocket, kThreadName, B_NORMAL_PRIORITY,
		(void *)new BMessenger(NULL, (BLooper *)this));
	if (fSockThread > B_ERROR) resume_thread(fSockThread);

};

status_t AIMManager::Send(Flap f) {
	fOutgoing.push_back(f);
}

status_t AIMManager::Login(const char *server, uint16 port, const char *username,
	const char *password) {

	unsigned char buffer[1024];
	unsigned char rbuffer[1024];
	struct hostent *he;
	struct sockaddr_in their_addr;
	struct fd_set fds;
	int16 sockfd = 0;
	int16 numbytes;


	LOG("AIMManager::Login", LOW, "Started (%s, %i, %s, %s)", server, port, username,
		password);

	if ((he = gethostbyname(server)) == NULL) {
		LOG("AIMManager", LOW, "Couldn't get Server name (%s)", server);
		return B_ERROR;
	};

	if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
		LOG("AIMManager", LOW, "Couldn't create socket");	
		return B_ERROR;
	};

	their_addr.sin_family = AF_INET;
	their_addr.sin_port = htons(port);
	their_addr.sin_addr = *((struct in_addr *)he->h_addr);
	memset(&(their_addr.sin_zero), 0, 8);

	if (connect(sockfd, (struct sockaddr *)&their_addr, sizeof(struct sockaddr)) == -1) {
		LOG("AIMManager", LOW, "Couldn't connect to %s:%i", server, port);
		return B_ERROR;
	};

	if ((numbytes = recv(sockfd, rbuffer, 1024, 0)) == -1) {
		LOG("AIMManager", LOW, "Couldn't recv()");
		return B_ERROR;
	};
	fIncomingSeqNum = (rbuffer[2] << 8) + rbuffer[3];
	
	Flap *flap = new Flap(FLAP_CHANNEL_OPEN_CON);
	flap->AddRawData((uchar []){0x00, 0x00}, 2);	// Dummy Padding;
	flap->AddRawData((uchar []){0x00, 0x00}, 2);
	flap->AddRawData((uchar []){0x00, 0x01}, 2);
	flap->AddTLV(0x0001, username, strlen(username));
	flap->AddTLV(0x0002, EncodePassword(password), strlen(password));
	flap->AddTLV(0x0003, "BeOS IM Kit by slaad", strlen("BeOS IM Kit by slaad"));
	flap->AddTLV(0x0016, (char []){0x00, 0x01}, 2);
	flap->AddTLV(0x0017, (char []){0x00, 0x00}, 2);
	flap->AddTLV(0x0018, (char []){0x00, 0x00}, 2);
	flap->AddTLV(0x001a, (char []){0x00, 0x00}, 2);
	flap->AddTLV(0x0003, "us", 2);
	flap->AddTLV(0x000f, "en", 2);	
	flap->AddTLV(0x0009, (char []){0x00, 0x15}, 2);

	LOG("Seq", LOW, "%i", fOutgoingSeqNum);

	if (send(sockfd, flap->Flatten(++fOutgoingSeqNum), flap->FlattenedSize(), 0)
		== -1) {
		
		LOG("AIMManager", LOW, "Couldn't send");
		delete flap;
		return B_ERROR;
	};

	if ((numbytes = recv(sockfd, rbuffer, 1024, 0)) == -1) {
		LOG("AIMManager", LOW, "Couldn't recv");
		delete flap;
		return B_ERROR;
	};
	
	uint16 offset = 6;
	bool keepParsing = true;
	
	char *bos = NULL;
	char *cookie = NULL;
	uint16 cookieSize = 0;
	while (keepParsing == true) {
		uint16 type = 0;
		uint16 length = 0;
		char *value = NULL;

		type = (rbuffer[offset] << 8) + rbuffer[offset + 1];
		offset += 2;
		length = (rbuffer[offset] << 8) + rbuffer[offset + 1];
		offset += 2;
		value = (char *)calloc(length, sizeof(char));
		memcpy(value, (const void *)(rbuffer + offset), length + 1);
		value[length] = '\0';
		offset += length;
		if (offset >= numbytes) keepParsing = false;
		if (type == 0x0005) bos = strdup(value);
		if (type == 0x0006) {
			cookie = (char *)calloc(length, sizeof(char));
			memcpy(cookie, value, length);
			cookieSize = length;
		};
		free(value);
	};

	char *colon = strchr(bos, ':');
	char *newserver = NULL;
	uint16 newport = atoi(colon + 1);
	newserver = (char *)calloc((colon - bos) + 1, sizeof(char));
	strncpy(newserver, bos, colon - bos);
	newserver[(colon - bos)] = '\0';

	free(bos);	
	close(sockfd);

	LOG("AIMManager::Login", LOW, "Need to reconnect to %s:%i", newserver, newport);

	if ((he = gethostbyname(newserver)) == NULL) {
		LOG("AIMManager", LOW, "Cannae resolve new server");
		delete flap;
		return B_ERROR;
	};
	
	if ((fSock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
		LOG("AIMManager", LOW, "Couldn't create new socket");
		delete flap;
		return B_ERROR;
	};

	their_addr.sin_family = AF_INET;
	their_addr.sin_port = htons(newport);
	their_addr.sin_addr = *((struct in_addr *)he->h_addr);
	memset(&(their_addr.sin_zero), 0, 8);
	
	if (connect(fSock, (struct sockaddr *)&their_addr, sizeof(struct sockaddr)) == -1) {
		LOG("AIMManager", LOW, "Couldn't connect to new server");
		delete flap;
		return B_ERROR;
	};
	
	memset(rbuffer, 0, 1024);
	if ((numbytes = recv(sockfd, rbuffer, 1024, 0)) == -1) {
		LOG("AIMManager", LOW, "Couldn't recv");
		delete flap;
		return B_ERROR;
	};
	fIncomingSeqNum = (rbuffer[2] << 8) + rbuffer[3];

	flap->Clear();
	flap->Channel(FLAP_CHANNEL_OPEN_CON);
	flap->AddRawData((uchar []){0x00, 0x00}, 2);	// Dummy Padding;
	flap->AddRawData((uchar []){0x00, 0x00}, 2);
	flap->AddRawData((uchar []){0x00, 0x01}, 2);
	flap->AddTLV(0x0006, cookie, cookieSize);

	if (send(fSock, flap->Flatten(++fOutgoingSeqNum), flap->FlattenedSize(), 0) == -1) {
		LOG("AIMManager", LOW, "Couldn't send Cookie");
		delete flap;
		return B_ERROR;
	};

	LOG("Seq", LOW, "%i", fOutgoingSeqNum);
	free(cookie);

	memset(rbuffer, 0, 1024);
	if ((numbytes = recv(fSock, rbuffer, 1024, 0)) == -1) {
		LOG("AIMManager", LOW, "Couldn't recv cookie response");
		delete flap;
		return B_ERROR;
	};

//	fIncomingSeqNum = (rbuffer[2] << 8) + rbuffer[3];

	flap->Clear();
	flap->Channel(FLAP_CHANNEL_SNAC_DATA);
	flap->AddRawData((uchar []){0x00, 0x00}, 2);	// Padding
	flap->AddRawData((uchar []){0x00, 0x01}, 2); // Family
	flap->AddRawData((uchar []){0x00, 0x06}, 2); // Subtype
	flap->AddRawData((uchar []){0x00, 0x00}, 2); // Flags
	flap->AddRawData((uchar []){0x00, 0x00, 0x04, 0x00}, 4); // ReqID
	
	if (send(fSock, flap->Flatten(++fOutgoingSeqNum), flap->FlattenedSize(), 0) == -1) {
		LOG("AIMManager", LOW, "Couldn't send rate");
		delete flap;
		return B_ERROR;
	};

	LOG("a", LOW, "Waiting for reply");

	memset(rbuffer, 0, 1024);
	if ((numbytes = recv(fSock, rbuffer, 1024, 0)) == -1) {
		perror("Rate get");
		LOG("AIMManager", LOW, "Couldn't get rate");
		delete flap;
		return B_ERROR;
	};
	
	LOG("a", LOW, "Got reply");
	
	flap->Clear();
	flap->Channel(FLAP_CHANNEL_SNAC_DATA);
	flap->AddRawData((uchar []){0x00, 0x00}, 2);	// Padding
	flap->AddRawData((uchar []){0x00, 0x01}, 2); // Family
	flap->AddRawData((uchar []){0x00, 0x08}, 2); // Subtype
	flap->AddRawData((uchar []){0x00, 0x00}, 2); // Flags
	flap->AddRawData((uchar []){0x00, 0x00, 0x04, 0x00}, 4); // ReqID
	flap->AddRawData((uchar []){0x00, 0x01}, 2);
	flap->AddRawData((uchar []){0x00, 0x02}, 2);
	flap->AddRawData((uchar []){0x00, 0x03}, 2);
	flap->AddRawData((uchar []){0x00, 0x04}, 2);

	if (send(fSock, flap->Flatten(++fOutgoingSeqNum), flap->FlattenedSize(), 0) == -1) {
		LOG("AIMManager", LOW, "Couldn't send rate ack");
		delete flap;
		return B_ERROR;
	};

	flap->Clear();
	flap->Channel(FLAP_CHANNEL_SNAC_DATA);
	flap->AddRawData((uchar []){0x00, 0x00}, 2);	// Padding
	flap->AddRawData((uchar []){0x00, 0x01}, 2); // Family
	flap->AddRawData((uchar []){0x00, 0x14}, 2); // Subtype
	flap->AddRawData((uchar []){0x00, 0x00}, 2); // Flags
	flap->AddRawData((uchar []){0x00, 0x00, 0x06, 0x00}, 4); // ReqID
	flap->AddRawData((uchar []){0x00, 0x00}, 2);
	flap->AddRawData((uchar []){0x00, 0x03}, 2);

	if (send(fSock, flap->Flatten(++fOutgoingSeqNum), flap->FlattenedSize(), 0) == -1) {
		LOG("AIMManager", LOW, "Couldn't send SPF");
		delete flap;
		return B_ERROR;
	};

	flap->Clear();
	flap->Channel(FLAP_CHANNEL_SNAC_DATA);
	flap->AddRawData((uchar []){0x00, 0x00}, 2);	// Padding
	flap->AddRawData((uchar []){0x00, 0x01}, 2); // Family
	flap->AddRawData((uchar []){0x00, 0x0e}, 2); // Subtype
	flap->AddRawData((uchar []){0x00, 0x00}, 2); // Flags
	flap->AddRawData((uchar []){0x00, 0x00, 0x07, 0x00}, 4); // ReqID
	flap->AddRawData((uchar []){0x00, 0x00}, 2);

	if (send(fSock, flap->Flatten(++fOutgoingSeqNum), flap->FlattenedSize(), 0) == -1) {
		LOG("AIMManager", LOW, "Couldn't send RPI");
		delete flap;
		return B_ERROR;
	};

	flap->Clear();
	flap->Channel(FLAP_CHANNEL_SNAC_DATA);
	flap->AddRawData((uchar []){0x00, 0x00}, 2);	// Padding
	flap->AddRawData((uchar []){0x00, 0x01}, 2); // Family
	flap->AddRawData((uchar []){0x00, 0x04}, 2); // Subtype
	flap->AddRawData((uchar []){0x00, 0x00}, 2); // Flags
	flap->AddRawData((uchar []){0x00, 0x00, 0x08, 0x00}, 4); // ReqID
	flap->AddRawData((uchar []){0x00, 0x17}, 2);

	if (send(fSock, flap->Flatten(++fOutgoingSeqNum), flap->FlattenedSize(), 0) == -1) {
		LOG("AIMManager", LOW, "Couldn't send ReqNewServ");
		delete flap;
		return B_ERROR;
	};

	
	flap->Clear();
	flap->Channel(FLAP_CHANNEL_SNAC_DATA);
	flap->AddRawData((uchar []){0x00, 0x00}, 2);	// Padding
	flap->AddRawData((uchar []){0x00, 0x03}, 2); // Family
	flap->AddRawData((uchar []){0x00, 0x04}, 2); // Subtype
	flap->AddRawData((uchar []){0x00, 0x00}, 2); // Flags
	flap->AddRawData((uchar []){0x00, 0x00, 0x0a, 0x00}, 4); // ReqID
	flap->AddRawData((uchar *)"industroslaad", strlen("industroslaad"));

	if (send(fSock, flap->Flatten(++fOutgoingSeqNum), flap->FlattenedSize(), 0) == -1) {
		LOG("AIMManager", LOW, "Couldn't send Add Buddy To List");
		delete flap;
		return B_ERROR;
	};

	flap->Clear();
	flap->Channel(FLAP_CHANNEL_SNAC_DATA);
	flap->AddRawData((uchar []){0x00, 0x00}, 2);	// Padding
	flap->AddRawData((uchar []){0x00, 0x02}, 2); // Family
	flap->AddRawData((uchar []){0x00, 0x04}, 2); // Subtype
	flap->AddRawData((uchar []){0x00, 0x00}, 2); // Flags
	flap->AddRawData((uchar []){0x00, 0x00, 0x0b, 0x00}, 4); // ReqID
	flap->AddTLV(0x0001, "text/x-aolrtf; charset=\"us-ascii\"", strlen("text/x-aolrtf; charset=\"us-ascii\""));
//	Profile
	flap->AddTLV(0x0002, "IM Kit Test User. The IM Kit is funky", strlen("IM Kit Test User. The IM Kit is funky"));
	flap->AddTLV(0x0003, "text/x-aolrtf; charset=\"us-ascii\"", strlen("text/x-aolrtf; charset=\"us-ascii\""));
//	Away message, NULL for not-away
//	sui.AddTLV(0x0004, "I'm not really away", strlen("I'm not really away"));
	flap->AddTLV(0x0000, "", 0);
//	Capabilities
	flap->AddTLV(0x0005, (char []){0x74, 0x8f, 0x24, 0x20, 0x62, 0x87, 0x11, 0xd1,
		0x82, 0x22, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00}, 16);
	
	if (send(fSock, flap->Flatten(++fOutgoingSeqNum), flap->FlattenedSize(), 0) == -1) {
		LOG("AIMManager", LOW, "Couldn't send Set Our Info");
		delete flap;
		return B_ERROR;
	};

	flap->Clear();
	flap->Channel(FLAP_CHANNEL_SNAC_DATA);
	flap->AddRawData((uchar []){0x00, 0x00}, 2);	// Padding
	flap->AddRawData((uchar []){0x00, 0x04}, 2); // Family
	flap->AddRawData((uchar []){0x00, 0x02}, 2); // Subtype
	flap->AddRawData((uchar []){0x00, 0x00}, 2); // Flags
	flap->AddRawData((uchar []){0x00, 0x00, 0x0c, 0x00}, 4); // ReqID
	flap->AddRawData((uchar []){0x00, 0x00}, 2);
	flap->AddRawData((uchar []){0x00, 0x00, 0x00, 0x03}, 4);
	flap->AddRawData((uchar []){0x1f, 0x40}, 2);
	flap->AddRawData((uchar []){0x03, 0xe7}, 2);
	flap->AddRawData((uchar []){0x03, 0xe7}, 2);
	flap->AddRawData((uchar []){0x00, 0x00}, 2);
	flap->AddRawData((uchar []){0x00, 0x00}, 2);
		
	if (send(fSock, flap->Flatten(++fOutgoingSeqNum), flap->FlattenedSize(), 0) == -1) {
		LOG("AIMManager", LOW, "Couldn't send ICBM");
		delete flap;
		return B_ERROR;
	};

	flap->Clear();
	flap->Channel(FLAP_CHANNEL_SNAC_DATA);
	flap->AddRawData((uchar []){0x00, 0x00}, 2);	// Padding
	flap->AddRawData((uchar []){0x00, 0x01}, 2); // Family
	flap->AddRawData((uchar []){0x00, 0x02}, 2); // Subtype
	flap->AddRawData((uchar []){0x00, 0x00}, 2); // Flags
	flap->AddRawData((uchar []){0x00, 0x00, 0x0d, 0x00}, 4); // ReqID
	flap->AddRawData((uchar []){0x00, 0x01}, 2);
	flap->AddRawData((uchar []){0x00, 0x03}, 2);
	flap->AddRawData((uchar []){0x00, 0x04}, 2);
	flap->AddRawData((uchar []){0x06, 0x86}, 2);
	flap->AddRawData((uchar []){0x00, 0x02}, 2);
	flap->AddRawData((uchar []){0x00, 0x01}, 2);
	flap->AddRawData((uchar []){0x00, 0x04}, 2);
	flap->AddRawData((uchar []){0x00, 0x01}, 2);
	flap->AddRawData((uchar []){0x00, 0x03}, 2);
	flap->AddRawData((uchar []){0x00, 0x01}, 2);
	flap->AddRawData((uchar []){0x00, 0x04}, 2);
	flap->AddRawData((uchar []){0x00, 0x01}, 2);
	flap->AddRawData((uchar []){0x00, 0x04}, 2);
	flap->AddRawData((uchar []){0x00, 0x01}, 2);
	flap->AddRawData((uchar []){0x00, 0x04}, 2);
	flap->AddRawData((uchar []){0x00, 0x09}, 2);
	flap->AddRawData((uchar []){0x00, 0x01}, 2);
	flap->AddRawData((uchar []){0x00, 0x04}, 2);
	flap->AddRawData((uchar []){0x00, 0x01}, 2);
	flap->AddRawData((uchar []){0x00, 0x0a}, 2);
	flap->AddRawData((uchar []){0x00, 0x01}, 2);
	flap->AddRawData((uchar []){0x00, 0x04}, 2);
	flap->AddRawData((uchar []){0x00, 0x01}, 2);
	flap->AddRawData((uchar []){0x00, 0x0b}, 2);
	flap->AddRawData((uchar []){0x00, 0x01}, 2);
	flap->AddRawData((uchar []){0x00, 0x04}, 2);
	flap->AddRawData((uchar []){0x00, 0x01}, 2);
		
	if (send(fSock, flap->Flatten(++fOutgoingSeqNum), flap->FlattenedSize(), 0) == -1) {
		LOG("AIMManager", LOW, "Couldn't send Client Ready");
		delete flap;
		return B_ERROR;
	};

	delete flap;

	return B_OK;
};

char *AIMManager::EncodePassword(const char *pass) {
	int32 passLen = strlen(pass);
	char *ret = (char *)calloc(passLen, sizeof(char));
	
	char encoding_table[] = {
		0xf3, 0xb3, 0x6c, 0x99,
		0x95, 0x3f, 0xac, 0xb6,
		0xc5, 0xfa, 0x6b, 0x63,
		0x69, 0x6c, 0xc3, 0x9f
	};

	// encode the password
	for(int32 i = 0; i < passLen; i++ )
		ret[i] = (pass[i] ^encoding_table[i]);
		
	return ret;
};

void AIMManager::MessageReceived(BMessage *msg) {
	switch (msg->what) {
		case AMAN_PULSE: {
//			printf("Pulsing\n");
		} break;
		
		case AMAN_GET_SOCKET: {
			printf("Socket requested\n");
			
			BMessage reply(B_REPLY);
			reply.AddInt32("socket", fSock);
			msg->SendReply(&reply);
		} break;
		default: {
			BLooper::MessageReceived(msg);
		};
	};
};


status_t AIMManager::MessageUser(const char *screenname, const char *message) {
	LOG("AIMManager::MessageUser", LOW, "Sending \"%s\" (%i) to %s (%i)\n",
		message, strlen(message), screenname, strlen(screenname));
		
	Flap *f = new Flap(FLAP_CHANNEL_SNAC_DATA);
	f->AddRawData((uchar []){0x00, 0x00}, 2); // Padding
	f->AddRawData((uchar []){0x00, 0x04}, 2); // Family
	f->AddRawData((uchar []){0x00, 0x06}, 2); // Subtype
	f->AddRawData((uchar []){0x00, 0x00}, 2); // Flags

	f->AddRawData((uchar []){0x00, 0xf0, 0x0e, 0x00}, 4); // ReqID
	f->AddRawData((uchar []){0x00, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x08, 0x03}, 8); // MSG-ID Cookie
	f->AddRawData((uchar []){0x00, 0x01}, 2);

	uint16 l = strlen(screenname);
	f->AddRawData((uchar *)&l, 1);
	f->AddRawData((uchar *)screenname, strlen(screenname));
	f->AddRawData((uchar []){0x00, 0x02}, 2);

	uint16 len = strlen(message);
	l = len + 0x0d;
	l = (l & 0xff00) >> 8;
	f->AddRawData((uchar *)&l, 1);
	l = (len + 0x0d) & 0x00ff;
	f->AddRawData((uchar *)&l, 1);

//	f->AddRawData((uchar []){((l & 0xff00) >> 8), (l & 0x00ff)}, 2);
	l = 0x05;
	f->AddRawData((uchar *)&l, 1);
	f->AddRawData((uchar []){0x01, 0x00}, 2);
	f->AddRawData((uchar []){0x01, 0x01}, 2);
	f->AddRawData((uchar []){0x01, 0x00}, 2);

	l = len + 0x04;
	l = (l & 0xff00) >> 8;
	f->AddRawData((uchar *)&l, 1);
	l = (len + 0x04) & 0x00ff;
	f->AddRawData((uchar *)&l, 1);
//	f->AddRawData((uchar []){(0 & 0xff00) >> 8, (l & 0x00ff)}, 2);
	f->AddRawData((uchar []){0x00, 0x00}, 2);
	f->AddRawData((uchar []){0x00, 0x00}, 2);

	for (uint16 i = 0; i < strlen(message); i++) {
		f->AddRawData((uchar *)&message[i], 1);
	};
//	f->AddRawData((uchar *)&message, len);

	if (send(fSock, f->Flatten(++fOutgoingSeqNum), f->FlattenedSize(), 0) == -1) {
		LOG("AIMManager::MessageUser", LOW, "(%s, %s)", screenname, message);
		delete f;
		return B_ERROR;
	};

	PrintHex((uchar *)f->Flatten(fOutgoingSeqNum), f->FlattenedSize());

	delete f;
	return B_OK;
};

int32 AIMManager::MonitorSocket(void *messenger) {
	BMessenger *msgr = reinterpret_cast<BMessenger *>(messenger);
	int32 socket = 0;

	if (msgr->IsValid()) {
		BMessage reply;

		status_t ret = 0;
		if ((ret = msgr->SendMessage(AMAN_GET_SOCKET, &reply)) == B_OK) {
			if ((ret = reply.FindInt32("socket", &socket)) != B_OK) {
				LOG("AIMManager::MonitorSocket", LOW, "Couldn't get socket: %i", ret);
				return B_ERROR;
			};
		} else {
			LOG("AIMManager::MonitorSocket", LOW, "Couldn't obtain socket: %i", ret);
			return B_ERROR;
		};

		struct fd_set read;
		struct fd_set error;
		int32 bytes;
		
		while (msgr->IsValid()) {
			bytes = 0;

			FD_ZERO(&read);
			FD_ZERO(&error);

			FD_SET(socket, &read);
			FD_SET(socket, &error);

			if (select(32, &read, NULL, &error, NULL) > 0) {
				if (FD_ISSET(socket, &error)) {
					LOG("AIMManager::MonitorSocket", LOW, "Error reading socket");
				};
				if (FD_ISSET(socket, &read)) {
					LOG("AIMManager::MonitorSocket", LOW, "Got data");
				};
			};
		};
	} else {
		LOG("AIMManager::MonitorSocket", LOW, "Messenger wasn't valid!\n");
		return B_ERROR;
	};

	return B_OK;
};
